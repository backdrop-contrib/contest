<?php
/* $Id$ */

/**
 * @file
 * Contest module.
 */

/**
 * Implementation of hook_help().
 */
function contest_help($section) {
  switch ($section) {
    case 'admin/help#contest':
      $output = '<p>'. t('The contest module.') .'</p>';
      return $output;
    case 'admin/modules#description':
      return t('Allows users to run contests currently based on votingAPI.');
    case 'node/add#contest':
      return t('Allows users to run contests currently based on votingAPI.');
  }
}


/**
 * Implementation of hook_perm().
 */
function contest_perm() {
  return array('administer contests','create contests', 'edit own contests');
}

/**
 * Implementation of hook_access().
 */
function contest_access($op, $node) {
  global $user;

  if ($op == 'create') {
    return user_access('create contests');
  }

  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own contests') && ($user->uid == $node->uid)) {
      return TRUE;
    }
  }
}

function contest_menu($may_cache) {
  global $user;

  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/contest', 'title' => t('contest'),
      'access' => user_access('create contests'));
  }
  else {
    // prizes tab on contest node
    /*
    if (arg(0) == 'node' && is_numeric(arg(1))) {
      $node = node_load(arg(1));
      if ($node->type == 'contest') {
        $items[] = array('path' => 'node/'. arg(1). '/prizes', 'title' => t('prizes'), 'callback' => 'contest_prizes', 'callback arguments' => array(arg(1)), 'access' => node_access('update', $node), 'type' => MENU_LOCAL_TASK, 'weight' => 7);
      }
    }
    */
  }
  return $items;
}

/**
 * Implementation of hook_node_info().
 */
function contest_node_info() {
  return array('contest' => array('name' => t('contest'), 'base' => 'contest'));
}

/**
 * Implementation of hook_form().
 */
function contest_form(&$node) {

  $form['title'] = array('#type' => 'textfield', '#title' => t('Title'), '#required' => TRUE, '#default_value' => $node->title, '#weight' => -5);

  $form['body_filter']['body'] = array('#type' => 'textarea', '#title' => t('Body'), '#default_value' => $node->body, '#rows' => 20, '#required' => TRUE);
  $form['body_filter']['format'] = filter_form($node->format);

  $form['contest_status'] = array('#type' => 'radios', '#title' => t('Contest status'), '#default_value' => $node->contest_status, '#options' => array(t('open'),t('closed')));

  $form['contest_maxnodes'] = array('#type' => 'textfield', '#title' => t('Node count to show'), '#default_value' => $node->contest_maxnodes, '#required' => TRUE);

  $form['contest_winners'] = array('#type' => 'textfield', '#title' => t('Number of winners'), '#default_value' => $node->contest_winners, '#required' => TRUE);

  $form['actions'] = array('#type' => 'fieldset', '#title' => 'Actions', '#collapsible' => 1, '#collapsed' => 1, '#description' => t('Actions which will happen after contest ends'));

  $form['actions']['publishing_action'] = array('#type' => 'radios', '#title' => t('Publishing options'), '#default_value' => $node->publishing_action, '#options' => array(t('none'),t('Republish'), t('Unpublish')));

  $form['actions']['promote_action'] = array(
  '#type' => 'checkboxes',
  '#title' => t('Promote options'),
  '#default_value' => unserialize($node->promote_action),
  '#options' => array(
    'promote' => t('Promote to front page'),
    'sticky' => t('Sticky at top of lists'))
  );

  $options = user_roles();
  $form['users'] = array('#type' => 'fieldset', '#title' => 'Omitt user roles', '#collapsible' => 1, '#collapsed' => 1, '#description' => t('Omitted user roles which won\'t participate'));

  $form['users']['omitted_roles'] = array('#type' => 'select', '#title' => t('Ommited user roles'), '#default_value' => unserialize($node->omitted_roles), '#options' => $options, '#description' => t('Select any user-role which should <em>not</em> participate in the Audience targetting system.'), '#multiple' => TRUE);

  $form['ntypes'] = array('#type' => 'fieldset', '#title' => 'Omitt node types', '#collapsible' => 1, '#collapsed' => 1, '#description' => t(''));

  // omitted types
  unset($options);
  foreach (node_get_types() as $type => $name) {
    $options[$type] = t($name);
  }
  // hide node types which are already serving as a group node
  unset($options['contest']);
  $form['ntypes']['omitted_types'] = array('#type' => 'select', '#title' => t('Omitted content types'), '#default_value' => unserialize($node->omitted_types), '#options' => $options, '#description' => t('Select any node types which should <em>not</em> participate in the Contest.'), '#multiple' => TRUE);

  $form['count_type'] = array('#type' => 'fieldset', '#title' => t('VotingApi settings'), '#collapsible' => TRUE, '#collapsed' => TRUE);
  $form['count_type']['counting_type'] = array(
    '#type' => 'textfield',
    '#title' => t('Counting type'),
    '#required' => TRUE,
    '#default_value' => $node->counting_type,
    '#weight' => 0,
    '#description' => 'percent, points,...'
  );

  // due date
  $form['date'] = array('#type' => 'fieldset', '#title' => t('Date settings'), '#collapsible' => TRUE, '#collapsed' => TRUE);
  if (!$node->start) $node->start = date('d/m/Y H:i', Time());
  $form['date']['start'] = array(
    '#type' => 'textfield',
    '#title' => t('Start date'),
    '#required' => FALSE,
    '#default_value' => $node->start,
    '#weight' => 0,
    '#description' => 'Format dd/mm/yyyy hh:mm'
  );

  if (!$node->end) $node->end = date('d/m/Y H:i', Time());
   $form['date']['end'] = array(
    '#type' => 'textfield',
    '#title' => t('End date'),
    '#required' => FALSE,
    '#default_value' => $node->end,
    '#weight' => 0,
    '#description' => 'Format dd/mm/yyyy hh:mm'
  );

  $form = contest_vocabulary_get($form, $node);
 # $form = contest_taxonomy_get($form);

  $form['log'] = array(
    '#type' => 'textarea',
    '#title' => t('Log message'),
    '#weight' => 5,
    '#description' => t('An explanation of the additions or updates being made to help other authors understand your motivations.')
  );
  return $form;
}

/**
* Implemenation of hook_load
* @param node object to load additional information for
* @return object with todo fields
*/
function contest_load($node) {
    $t = db_fetch_object(db_query('SELECT omitted_types, counting_type, contest_status, contest_maxnodes, start, end, publishing_action, promote_action, omitted_roles, incall_vid, contest_winners, vids FROM {nodecontest} WHERE nid = %d', $node->nid));
    return $t;
}

/**
* Implemenation of hook_prepare
* @param node object to display
*/
function contest_prepare(&$node) {
    $node->start = date('d/m/Y H:i', $node->start);
    $node->end = date('d/m/Y H:i', $node->end);
}

/**
* Implementation of hook_insert, which saves todo-specific information
* into the todo table
* @param node object
*/
function contest_insert($node) {
  // normally, we'd try strtotime, but it won't handle the inverse
  // dd/mm/yyyy formats, so generate the timestamp ourselves
  preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d) (\d\d):(\d\d)$/', $node->start, $m);
  $start = mktime($m[4], $m[5], 0, $m[2], $m[1], $m[3]);
  preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d) (\d\d):(\d\d)$/', $node->end, $m);
  $end = mktime($m[4], $m[5], 0, $m[2], $m[1], $m[3]);

  // get taxonomy vocabs
  $vids = array();
  foreach ($node->taxonomy_check as $term){
    foreach ($term as $vid){
      if ($vid != 0){
        $vids[] = $vid;
      }
    }
  }

  db_query("INSERT INTO {nodecontest} (nid, omitted_types, counting_type, start, end, publishing_action, promote_action, omitted_roles, contest_status, contest_maxnodes, incall_vid, contest_winners, vids) VALUES (%d, '%s', '%s', %d, %d, '%s', '%s', '%s', %d, %d, '%s', %d, '%s')", $node->nid, serialize($node->omitted_types), $node->counting_type, $start, $end, $node->publishing_action, serialize($node->promote_action), serialize($node->omitted_roles), $node->content_status, $node->contest_maxnodes, serialize($incall_vid), $node->contest_winners, serialize($vids));
}

/**
* Implementation of hook_update, which saves updated todo-specific
* information into the todo table
* @param node object
*/
function contest_update($node) {
  $vids = array();
  foreach ($node->taxonomy_check as $term){
    foreach ($term as $vid){
      if ($vid != 0){
        $vids[] = $vid;
      }
    }
  }
  taxonomy_get_term_by_name($typed_term);
  // normally, we'd try strtotime, but it won't handle the inverse
  // dd/mm/yyyy formats, so generate the timestamp ourselves
  preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d) (\d\d):(\d\d)$/', $node->start, $m);
  $start = mktime($m[4], $m[5], 0, $m[2], $m[1], $m[3]);
  preg_match('/^(\d\d)\/(\d\d)\/(\d\d\d\d) (\d\d):(\d\d)$/', $node->end, $m);
  $end = mktime($m[4], $m[5], 0, $m[2], $m[1], $m[3]);
  db_query("UPDATE {nodecontest} SET omitted_types = '%s', counting_type = '%s', start = %d, end = %d, publishing_action = '%s', promote_action = '%s', omitted_roles = '%s', contest_status = %d, contest_maxnodes = %d, incall_vid = '%s', contest_winners = %d, vids = '%s' WHERE nid = %d", serialize($node->omitted_types), $node->counting_type, $start, $end, $node->publishing_action, serialize($node->promote_action), serialize($node->omitted_roles), $node->contest_status, $node->contest_maxnodes, serialize($incall_vid), $node->contest_winners, serialize($vids), $node->nid);
}

/**
 * Generate a form for selecting vocabularies
 */
function contest_vocabulary_get($form, $node) {
  $vocabularies = taxonomy_get_vocabularies();
  $options = array();
  foreach ($vocabularies as $vocabulary) {
    $options += array($vocabulary->vid => $vocabulary->name);
  }
  $form['taxonomy_check'][$vocabulary->vid] = array(
    '#type' => 'checkboxes',
    '#title' => t('Posts in vocabularies'),
    '#default_value' => unserialize($node->vids),
    '#options' => $options
  );
  $form['taxonomy_check'] += array('#type' => 'fieldset', '#title' => t('Vocabularies'), '#collapsible' => TRUE, '#collapsed' => TRUE, '#tree' => TRUE, '#weight' => 0);

  return $form;
}

/**
 * Generate a form for selecting terms.
 */
function contest_taxonomy_get($form) {
    $node = $form['#node'];

    $c = db_query(db_rewrite_sql("SELECT v.* FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid ORDER BY v.weight, v.name", 'v', 'vid'));

    $terms = unserialize($node->incall_vid);

    while ($vocabulary = db_fetch_object($c)) {
      $typed_terms = array();
        foreach ($terms as $term) {
          // Extract terms belonging to the vocabulary in question.
          if ($term[vid] == $vocabulary->vid) {
            // Commas and quotes in terms are special cases, so encode 'em.
            if (preg_match('/,/', $term[name]) || preg_match('/"/', $term[name])) {
              $term[name] = '"'.preg_replace('/"/', '""', $term[name].'"');
            }
            $typed_terms[] = $term[name];
          }
        }
        $typed_string = implode(', ', $typed_terms) . (array_key_exists('tags', $terms) ? $terms['tags'][$vocabulary->vid] : NULL);

        if ($vocabulary->help) {
          $help = $vocabulary->help;
        }
        else {
          $help = t('A comma-separated list of terms.  Example: funny, bungee jumping, "Company, Inc.".');
        }
        $form['taxonomy_list']['tags'][$vocabulary->vid] = array('#type' => 'textfield',
          '#title' => $vocabulary->name,
          '#description' => $help,
          '#required' => FALSE,
          '#default_value' => $typed_string,
          '#autocomplete_path' => 'taxonomy/autocomplete/'. $vocabulary->vid,
          '#weight' => $vocabulary->weight,
          '#maxlength' => 255,
        );
        drupal_set_message('vid1>'.$incall_vid[1], 'error');
    }
    if (isset($form['taxonomy_list'])) {
      $form['taxonomy_list'] += array('#type' => 'fieldset', '#title' => t('Categories'), '#collapsible' => TRUE, '#collapsed' => TRUE, '#tree' => TRUE, '#weight' => 3);
    }

    return $form;
}


/**
* Implementation of hook_view, add our node specific information
* @param node object to display
* @param boolean is this a teaser or full node?
* @param boolean is this displaying on its own page
*/
function contest_view(&$node, $teaser = FALSE, $page = FALSE) {
    $node = node_prepare($node, $teaser);
    $contest_info = theme('contest_basic_view', $node);
    $node->body .= $contest_info;
    $node->teaser .= $contest_info;
}

/**
* Theme function to display additional node data
* @param node to display
* @return HTML string with additional node information
*/
function theme_contest_basic_view($node){

  $output .= '<div class="contest_view_duedate">';
  $output .= t('Start date: %start', array('%start' => Date("d/m/Y H:i",$node->start)));
  $output .= '</div>';
  $output .= '<div class="contest_view_duedate">';
  $output .= t('End date: %end', array('%end' => Date("d/m/Y H:i",$node->end)));
  $output .= '</div>';

  $output .= 'Number of winners: '.$node->contest_winners.'<br />';

  $output .= contest_get_status($node);
  if (time() > $node->end || $node->contest_status == 1){
    $output .= contest_get_winners($node);
  }
  else {
    $output .= contest_get_nodes($node);
  }
  return $output;
}

function contest_get_status($node){
  $output = '<h2>Current status</h2>';
  // format date
  if (time() > $node->end || $node->contest_status == 1) $status = 'closed';
  $status = $status ? $status : 'open';
  $output .= 'Status: '.$status.'<br />';
  $counting_type_q = $node->counting_type;
  $output .= 'Counting type: '.$counting_type_q.'<br />';
  return $output;
}

function contest_get_winners($node){
  $result = db_query('SELECT winners, votes FROM {nodecontest_winners} WHERE nid = %d', $node->nid);
  if (!db_num_rows($result)){
    $output = t('Counting...');
  }
  else {
    $header = array(t('title'), t('Author'), t('Average vote value'));
    $res = db_fetch_object($result);
    $winners = unserialize($res->winners);
    $output .= theme('table', $header, $winners);
  }
  return $output;
}

function contest_get_nodes($node){
  //working variables
  // $node->omitted_types, $node->counting_type, $node->start, $node->end, $node->omitted_roles

  // don't forget to ommit contest type
  $query_ntype = " AND n.type != 'contest'";
  // build node types omitt query
  if ($node->omitted_types) {
    $omitted_types = unserialize($node->omitted_types);
    foreach ($omitted_types as $ntype){
      $query_ntype .= " AND n.type != '".$ntype."'";
    }
  }

  // build vocabulary query
  $vids = unserialize($node->vids);
  $cvid = count($vids);
  $c = 0;
  unset($qu);
  foreach ($vids as $vid){
    $c++;
    $qu .= 'td.vid = '.$vid;
    if ($c < $cvid) $qu .= ' || ';
  }

  if ($qu){
    $query_vid = 'JOIN {term_node} t ON n.nid = t.nid JOIN {term_data} td ON t.tid = td.tid';
    $query_vid_where = ' AND ('.$qu.') ';
  }

  // build date query
  if (($node->start) AND ($node->end)){
    $query_date = ' AND v.timestamp > '.$node->start.' AND v.timestamp < '.$node->end;
  }

  $header = array(t('Title'), t('Author'), t('Average vote value'));

  $query = 'SELECT n.nid, n.title, n.uid, u.name, AVG(v.value) vv FROM {node} as n RIGHT JOIN {votingapi_vote} as v on n.nid = v.content_id JOIN {users} u on n.uid = u.uid '.$query_vid.' WHERE v.value_type = "%s" '.$query_ntype.$query_date.$query_vid_where.' GROUP BY v.content_id ORDER BY vv DESC LIMIT 0,'.$node->contest_maxnodes;

  $result = db_query($query, $node->counting_type);
  while ($res = db_fetch_object($result)) {
    $rows[] = array(
      l($res->title, 'node/'.$res->nid),
      l($res->name, 'user/'.$res->uid),
      $res->vv);
  }
  $output .= theme('table', $header, $rows);
  return $output;
}

function contest_cron(){
  // get contests
  $result = db_query('SELECT nid FROM {nodecontest} WHERE end < %d AND contest_status = 0', time());
  while ($res = db_fetch_object($result)) {
    $node = node_load($res->nid);
    // don't forget to ommit contest type
    $query_ntype = " AND n.type != 'contest'";
    // build node types omitt query
    if ($node->omitted_types) {
      $omitted_types = unserialize($node->omitted_types);
      foreach ($omitted_types as $ntype){
        $query_ntype .= " AND n.type != '".$ntype."'";
      }
    }

    // build vocabulary query
    $vids = unserialize($node->vids);
    $cvid = count($vids);
    $c = 0;
    unset($qu);
    foreach ($vids as $vid){
      $c++;
      $qu .= 'td.vid = '.$vid;
      if ($c < $cvid) $qu .= ' || ';
    }

    if ($qu){
      $query_vid = 'JOIN {term_node} t ON n.nid = t.nid JOIN {term_data} td ON t.tid = td.tid';
      $query_vid_where = ' AND ('.$qu.') ';
    }

    // build date query
    if (($node->start) AND ($node->end)){
      $query_date = ' AND v.timestamp > '.$node->start.' AND v.timestamp < '.$node->end;
    }

    $query = 'SELECT n.nid, n.title, n.uid, u.name, AVG(v.value) vv FROM {node} as n RIGHT JOIN {votingapi_vote} as v on n.nid = v.content_id JOIN {users} u on n.uid = u.uid '.$query_vid.' WHERE v.value_type = "%s" '.$query_ntype.$query_date.$query_vid_where.' GROUP BY v.content_id ORDER BY vv DESC LIMIT 0,'.$node->contest_winners;

    $nresult = db_query($query, $node->counting_type, $node->contest_winners);
    $winners = array();
    while ($nres = db_fetch_object($nresult)) {
      $winners[] = array('node' => l($nres->title, 'node/'.$nres->nid), 'author' => l($nres->name, 'user/'.$nres->uid), 'votes' => $nres->vv);
    }
    $winners = serialize($winners);
    db_query('INSERT INTO {nodecontest_winners} (nid, winners, votes) VALUES (%d, "%s", "%s")', $node->nid, $winners, $votes);
    db_query('UPDATE {nodecontest} SET contest_status = 1 WHERE nid = %d', $node->nid);
    // publishing actions
    if ($node->publishing_action == 1){
      db_query('UPDATE {node} SET changed = %d WHERE nid = %d', time(), $node->nid);
    } else if ($node->publishing_action == 2){
      db_query('UPDATE {node} SET status = %d WHERE nid = %d', 0, $node->nid);
    }
    // promote options
    foreach(unserialize($node->promote_action) as $promote_action){
      if ($promote_action == 'promote'){
        db_query('UPDATE {node} SET promote = %d WHERE nid = %d', 1, $node->nid);
      } else if ($promote_action == 'sticky'){
        db_query('UPDATE {node} SET sticky = %d WHERE nid = %d', 1, $node->nid);
      }
    }

    unset($node);
  }
}